<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ポテンシャル付きUnion-Find</title>
  <link rel="stylesheet" href="/kyoprolibrary/assets/css/styles.css">

</head>
<body>
  <header class="site-header">
    <h1 class="site-title"><a href="/kyoprolibrary/">競技プログラミングライブラリ</a></h1>
  </header>
  <main class="page-content">
    <h2>説明</h2>
<div>
  <p>ポテンシャル付きUnion-Findは、各要素間の「差分」や「ポテンシャル」を管理する拡張版です。</p>

<p>例えば、以下のような用途に使えます：</p>
<ul>
  <li>グラフ上の重み付き辺の管理。</li>
  <li>制約付き等式の判定。</li>
</ul>

<p>以下はそのC++コードの実装例です。</p>


</div>

<h2>コード</h2>
<div class="code-block">
  <pre><code class="language-cpp">

// Potentialized Union-Find構造体
// 各要素間のポテンシャル差を管理する
class PotentializedUnionFind {
private:
    std::vector&lt;int&gt; parent;      // 親ノード
    std::vector&lt;int64_t&gt; weight;  // weight[x]: potential[x] - potential[parent[x]]

public:
    // コンストラクタ
    PotentializedUnionFind(int n) : parent(n), weight(n, 0) {
        for (int i = 0; i &lt; n; ++i)
            parent[i] = i;
    }

    // xの根を見つける（経路圧縮あり）
    // weight[x]をpotential[x] - potential[root]に更新
    int root(int x) {
        if (parent[x] == x)
            return x;
        int r = root(parent[x]);
        weight[x] += weight[parent[x]];
        return parent[x] = r;
    }

    // xとyをポテンシャル差wで併合
    // potential[y] = potential[x] + wとなるようにする
    // 一貫性が取れない場合はfalseを返す
    bool unite(int x, int y, int64_t w) {
        int rx = root(x);
        int ry = root(y);
        if (rx == ry) {
            // 一貫性のチェック
            if (potential(y) - potential(x) != w)
                return false;
            else
                return true;
        }
        w = w + weight[x] - weight[y]; // weightを調整
        parent[ry] = rx;
        weight[ry] = -w;
        return true;
    }

    // xのポテンシャルを取得
    int64_t potential(int x) {
        root(x); // weight[x]を更新
        return weight[x];
    }

    // xからyへのポテンシャル差（potential[y] - potential[x]）を取得
    // 連結していない場合はstd::nulloptを返す
    std::optional&lt;int64_t&gt; diff(int x, int y) {
        if (root(x) != root(y))
            return std::nullopt;
        return potential(y) - potential(x);
    }

    // xとyが同じグループに属するかを判定
    bool same(int x, int y) {
        return root(x) == root(y);
    }
};

  </code></pre>
  <button onclick="copyCode(this)">Copy</button>
</div>
<div style="text-align: center; margin-top: 20px;">
  <a href="/kyoprolibrary/" class="home-button">Homeへ戻る</a>
</div>

  </main>
  <footer class="site-footer">
  </footer>
  <script src="/kyoprolibrary/assets/js/copy.js"></script>
</body>
</html>
