<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>モノイド付きUnion-Find</title>
  <link rel="stylesheet" href="/kyoprolibrary/assets/css/styles.css">

</head>
<body>
  <header class="site-header">
    <h1 class="site-title"><a href="/kyoprolibrary/">競技プログラミングライブラリ</a></h1>
  </header>
  <main class="page-content">
    <h2>説明</h2>
<div>
  <p>モノイド付きUnion-Findは、各連結成分に累積値を持たせることができる拡張です。</p>

<p>例えば、以下のような用途に使えます：</p>
<ul>
  <li>各連結成分の「合計値」「最大値」「最小値」などの累積値を計算。</li>
</ul>

<p>以下はそのC++コードの実装例です。</p>


</div>

<h2>コード</h2>
<div class="code-block">
  <pre><code class="language-cpp">

// 可換モノイドを乗せたUnion-Find構造体
// 各連結成分のモノイド値を管理する
template&lt;typename T, typename MonoidOp&gt;
class MonoidUnionFind {
private:
    std::vector&lt;int&gt; parent; // 親ノード
    std::vector&lt;int&gt; size;   // 各木のサイズ
    std::vector&lt;T&gt; data;     // 各連結成分のモノイド値
    int num_groups;          // グループの数
    MonoidOp op;             // モノイド演算

public:
    // コンストラクタ
    MonoidUnionFind(const std::vector&lt;T&gt;&amp; initial_data, MonoidOp op)
        : parent(initial_data.size()), size(initial_data.size(), 1), data(initial_data), num_groups(initial_data.size()), op(op) {
        for (int i = 0; i &lt; parent.size(); ++i)
            parent[i] = i;
    }

    // xの根を見つける（経路圧縮あり）
    int root(int x) {
        if (parent[x] == x)
            return x;
        else {
            parent[x] = root(parent[x]); // 経路圧縮
            return parent[x];
        }
    }

    // xとyが同じグループに属するかを判定
    bool same(int x, int y) {
        return root(x) == root(y);
    }

    // xとyのグループを併合
    // 既に同じグループの場合はfalseを返す
    bool unite(int x, int y) {
        x = root(x);
        y = root(y);
        if (x == y)
            return false;

        // サイズによる合併
        if (size[x] &lt; size[y])
            std::swap(x, y);

        parent[y] = x;
        size[x] += size[y];
        data[x] = op(data[x], data[y]); // モノイド値を更新
        --num_groups;
        return true;
    }

    // xが属するグループのサイズを取得
    int same_count(int x) {
        return size[root(x)];
    }

    // xが属するグループのモノイド値を取得
    T same_data(int x) {
        return data[root(x)];
    }

    // グループの数を取得
    int num_groups() const {
        return num_groups;
    }

    // グループを取得
    std::vector&lt;std::vector&lt;int&gt;&gt; groups() {
        int n = parent.size();
        std::vector&lt;int&gt; root_ids(n);
        std::vector&lt;int&gt; group_size(n);
        for (int i = 0; i &lt; n; ++i) {
            root_ids[i] = root(i);
            group_size[root_ids[i]]++;
        }
        std::vector&lt;std::vector&lt;int&gt;&gt; result(n);
        for (int i = 0; i &lt; n; ++i) {
            result[root_ids[i]].push_back(i);
        }
        // 空でないグループのみを収集
        std::vector&lt;std::vector&lt;int&gt;&gt; groups;
        for (auto&amp; group : result) {
            if (!group.empty())
                groups.push_back(group);
        }
        return groups;
    }
};

  </code></pre>
  <button onclick="copyCode(this)">Copy</button>
</div>
<div style="text-align: center; margin-top: 20px;">
  <a href="/kyoprolibrary/" class="home-button">Homeへ戻る</a>
</div>

  </main>
  <footer class="site-footer">
  </footer>
  <script src="/kyoprolibrary/assets/js/copy.js"></script>
</body>
</html>
